<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>0x7df</title><link href="http://0x7df.github.io/" rel="alternate"></link><link href="http://0x7df.github.io/feeds/programming.atom.xml" rel="self"></link><id>http://0x7df.github.io/</id><updated>2015-10-03T20:06:00+01:00</updated><entry><title>Static site generation, Pelican, and GitHub hosting</title><link href="http://0x7df.github.io/static-site-generation.html" rel="alternate"></link><published>2015-10-03T20:06:00+01:00</published><updated>2015-10-03T20:06:00+01:00</updated><author><name>0x7df</name></author><id>tag:0x7df.github.io,2015-10-03:static-site-generation.html</id><summary type="html">&lt;p&gt;This post discusses moving setting up and using a static site generator,
&lt;a href="http://blog.getpelican.com"&gt;Pelican&lt;/a&gt;, and moving existing posts from &lt;a href="http://www.wordpress.com"&gt;Wordpress&lt;/a&gt; to Pelican.&lt;/p&gt;
&lt;h2&gt;Comparing and choosing a generator&lt;/h2&gt;
&lt;p&gt;Many options are available for static site generation, with
&lt;a href="http://octopress.org"&gt;Octopress&lt;/a&gt; being a popular choice. I was interested in a Python-
based one, &lt;a href="https://jakevdp.github.io/blog/2013/05/07/migrating-from-octopress-to-pelican"&gt;for reasons that have been discussed elsewhere&lt;/a&gt;, and the
usual options that come up are &lt;a href="http://hyde.github.io"&gt;Hyde&lt;/a&gt;, &lt;a href="https://getnikola.com"&gt;Nikola&lt;/a&gt;, and
Pelican. &lt;a href="https://jakevdp.github.io/blog/2013/05/07/migrating-from-octopress-to-pelican"&gt;The article cited above&lt;/a&gt; suggested Hyde wasn't
well documented, so I skipped that altogether in the interests of time. The
Nikola documentation looked great, so I started with that; however, I spent
quite a while trying to install it, eventually with no luck. I needed to
install some prerequisites, the installation took a long time, and I ended up
with some missing packages. I'm sure another hour of Googling
&lt;a href="http://stackoverflow.com"&gt;StackOverflow&lt;/a&gt; and messing would have sorted it, but I lost
interest and moved on to Pelican; this &lt;a href="http://docs.getpelican.com/en/stable/quickstart.html"&gt;installed out of the box in a few
seconds&lt;/a&gt;, and I was away.&lt;/p&gt;
&lt;h2&gt;Importing from Wordpress&lt;/h2&gt;
&lt;p&gt;Importing from Wordpress just involves exporting the &lt;a href="http://0x7df.wordpress.com"&gt;original blog&lt;/a&gt; as
an XML file, which can be done from the "WP Admin" menu under "Tools". Pelican
provides a command for importing from this file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;wpfile&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;markdown&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="nb"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;wordpress&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;--wpfile&lt;/code&gt; flag specifies that the source is Wordpress (various
alternatives are available), the &lt;code&gt;-m&lt;/code&gt; option specified that the output should
be Markdown (as opposed to reStructured Text), and &lt;code&gt;--dir-page&lt;/code&gt; tells Pelican
to include the "Pages" from the Wordpress blog as well as the blog articles,
and put them in a &lt;code&gt;pages&lt;/code&gt; directory.&lt;/p&gt;
&lt;h2&gt;Maths pain&lt;/h2&gt;
&lt;p&gt;The original Wordpress articles that I imported contained a lot of maths, and
there was a significant amount of pain involved in converting the syntax used
by Wordpress to the syntax required by Pelican. in fact, Pelican doesn't
natively support maths, so a plugin is required: for this I used
&lt;a href="https://github.com/barrysteyn/pelican_plugin-render_math"&gt;render-math&lt;/a&gt;. As per the docs, for this I needed to install
&lt;a href="https://github.com/mintchaos/typogrify"&gt;Typogrify&lt;/a&gt; first, then add the following to the &lt;code&gt;pelicanconf.py&lt;/code&gt;
settings file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;PLUGIN_PATHS = [&amp;quot;..&amp;quot;]
PLUGINS = [&amp;quot;pelican_plugin-render_math&amp;quot;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to point Pelican at the location where I cloned the plugin.&lt;/p&gt;
&lt;p&gt;The text wrangling that was required to convert the Wordpress-syntax maths
delimiters:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;\&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;latex&lt;/span&gt;&lt;span class="x"&gt; ...maths... \&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;latex&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to those required for Pelican (i.e.:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$$ ...maths... $$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;for displayed equations and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ...math...$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;for in-line equations), was both annoying and unnecessary in theory (since
both platforms are using LaTeX, dammit), and is the subject of &lt;a href="http://0x7df.github.io/drafts/slug.html"&gt;a different
post&lt;/a&gt;. Once
done, I could move on to themes.&lt;/p&gt;
&lt;h2&gt;Pelican themes&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://pelicanthemes.com/"&gt;This website&lt;/a&gt; shows examples of available themes, from
which I chose the &lt;a href="https://github.com/molivier/nest"&gt;Nest&lt;/a&gt; theme; I cloned this directly into the Pelican
install directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd /usr/local/lib/python2.7/dist-packages/pelican/themes/
sudo git clone https://github.com/molivier/nest.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(The &lt;code&gt;pelican-themes -lv&lt;/code&gt; command can be used to determine the path to the
Pelican installation directory.)&lt;/p&gt;
&lt;p&gt;(Afterwards I realised a &lt;a href="http://github.com"&gt;GitHub&lt;/a&gt; repository &lt;a href="https://github.com/getpelican/pelican-themes"&gt;pelican-themes&lt;/a&gt; containing
a large number of themes is available, making it a lot easier to switch while
looking for a good theme.)&lt;/p&gt;
&lt;h2&gt;Deployment to GitHub&lt;/h2&gt;
&lt;p&gt;Although I have a domain - &lt;a href="http://0x7df.io"&gt;0x7df.io&lt;/a&gt; - and a website hosted
on &lt;a href="http://aws.amazon.com/"&gt;Amazon Web Services&lt;/a&gt;, I wanted both to keep this separate to begin
with, and try out hosting on &lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are two ways to manage a website/blog on GitHub pages. The first is to
create a special branch, which has to be called &lt;code&gt;gh-pages&lt;/code&gt; inside a repository;
the web documents committed on that branch then become available at:
&lt;code&gt;http://username.github.io/project/&lt;/code&gt;. This is ideal for creating
project-specific sites, like documentation. The second method, which is what I
used, is to create a special repository, called &lt;code&gt;username.github.io&lt;/code&gt; which
contains the web pages. These are then available at
&lt;code&gt;http://username.github.io/&lt;/code&gt;; they're considered the general user or
organisation web pages, as opposed to being specific to any one project. In
this case, the data doesn't need to be on the &lt;code&gt;gh-pages&lt;/code&gt; branch, but can be on
the more usual branch &lt;code&gt;master&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I used the &lt;a href="https://github.com/davisp/ghp-import/"&gt;ghp-import&lt;/a&gt; tool to do the uploading - this is used by the
Pelican &lt;code&gt;Makefile&lt;/code&gt; and is recommended &lt;a href="http://martinbrochhaus.com/pelican2.html"&gt;elsewhere&lt;/a&gt;. I installed it
with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install ghp-import
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;even though this isn't documented. As suggested &lt;a href="http://martinbrochhaus.com/pelican2.html#comment-1819417669"&gt;here&lt;/a&gt;, I added all
the content and tools to a
different branch called &lt;code&gt;source&lt;/code&gt;, but it can be anything - to keep it
separate from the output, which I want to commit to the &lt;code&gt;master&lt;/code&gt; branch. After
making changes to the content, running &lt;code&gt;make html&lt;/code&gt; to re-build, checking on a
local development server that runs in the background (initiated by &lt;code&gt;python -m
pelican.server &amp;amp;&lt;/code&gt; inside the &lt;code&gt;output&lt;/code&gt; directory), then committing to the
&lt;code&gt;source&lt;/code&gt; branch of my repository, I can just run &lt;code&gt;make github&lt;/code&gt; to call
&lt;code&gt;ghp-import&lt;/code&gt;. This commits the changes to the built website (in the &lt;code&gt;output&lt;/code&gt;
directory) to branch &lt;code&gt;master&lt;/code&gt;, and pushes the modified &lt;code&gt;master&lt;/code&gt; branch to the
repository on GitHub. With this workflow there is never a need to explicitly
switch to &lt;code&gt;master&lt;/code&gt; and do any commits - this is all handled by &lt;code&gt;ghp-import&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you're using the project-specific &lt;code&gt;gh-pages&lt;/code&gt; branch, the &lt;code&gt;ghp-import&lt;/code&gt; will
still do the job. It defaults actually to committing the built website to this
branch, and in my workflow requires the &lt;code&gt;-b master&lt;/code&gt; switch to tell it to commit
to &lt;code&gt;master&lt;/code&gt; instead. Note that the &lt;code&gt;-p&lt;/code&gt; flag to &lt;code&gt;ghp-import&lt;/code&gt; will handle the
push to GitHub, although in the Pelican Makefile this flag isn't used and the
push is a separate command.&lt;/p&gt;
&lt;p&gt;Either way, it's worth being very clear that &lt;code&gt;ghp-import&lt;/code&gt; treats the branch it
commits to - &lt;code&gt;gh-pages&lt;/code&gt; by default or whatever branch you specify if the &lt;code&gt;-b&lt;/code&gt;
flag is supplied - as &lt;em&gt;totally derivative&lt;/em&gt;. Assume it blows away whatever is
already there and replaces it with the new content. So you never manually
modify anything on that branch; keep all your content, configuration files,
tools, and anything else you care about, on a different branch, and keep the
destination branch for &lt;code&gt;ghp-import&lt;/code&gt; clean.&lt;/p&gt;</summary><category term="pelican"></category><category term="publishing"></category><category term="blog"></category><category term="python"></category><category term="github"></category><category term="latex"></category></entry><entry><title>Python wordcloud for WordPress</title><link href="http://0x7df.github.io/python-wordcloud-for-wordpress.html" rel="alternate"></link><published>2015-05-10T12:06:00+01:00</published><updated>2015-05-10T12:06:00+01:00</updated><author><name>0x7df</name></author><id>tag:0x7df.github.io,2015-05-10:python-wordcloud-for-wordpress.html</id><summary type="html">&lt;p&gt;There is a &lt;a href="http://www.python.org"&gt;Python&lt;/a&gt; routine available on
&lt;a href="https://github.com/"&gt;Github&lt;/a&gt; for creating a word cloud, created by
&lt;a href="http://peekaboo-vision.blogspot.co.uk/"&gt;Andreas Mueller&lt;/a&gt;:
&lt;a href="https://github.com/amueller/word_cloud"&gt;https://github.com/amueller/word_cloud&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sebastianraschka.com/Articles/2014_twitter_wordcloud.html"&gt;A blog post
here&lt;/a&gt;,
and &lt;a href="https://github.com/rasbt/datacollect"&gt;the Github repo that it goes
with&lt;/a&gt; (both due to &lt;a href="http://sebastianraschka.com/"&gt;Sebastien
Raschka&lt;/a&gt;), make it easy to use the
&lt;a href="https://dev.twitter.com/rest/public"&gt;Twitter API&lt;/a&gt; to download your
&lt;a href="https://support.twitter.com/articles/164083-what-s-a-twitter-timeline#"&gt;Twitter
timeline&lt;/a&gt;
(as a &lt;a href="http://en.wikipedia.org/wiki/Comma-separated_values"&gt;CSV&lt;/a&gt; file),
and then use the word cloud script to produce a word cloud from it.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://0x7df.files.wordpress.com/2015/04/my_twitter_wordcloud_1.png"&gt;&lt;img alt="my_twitter_wordcloud_1" src="https://0x7df.files.wordpress.com/2015/04/my_twitter_wordcloud_1.png?w=660" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To add something to this, I did the same thing with my
&lt;a href="https://wordpress.com"&gt;WordPress&lt;/a&gt; blog posts. I didn't want to bother
fighting with the WordPress API, so I simply exported the blog contents
to an XML file, which WordPress allows you to do through the admin
interface (so you can archive your blog locally and/or transfer it into
a different blog). Hence, this really just ends up being about XML
parsing. Here is the source code:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
#!/usr/bin/python&lt;/p&gt;
&lt;p&gt;from HTMLParser import HTMLParser&lt;br /&gt;
import xml.etree.ElementTree as ET&lt;br /&gt;
import matplotlib.pyplot as plt&lt;br /&gt;
from wordcloud import WordCloud, STOPWORDS&lt;/p&gt;
&lt;p&gt;#
http://stackoverflow.com/questions/753052/strip-html-from-strings-in-python&lt;br /&gt;
class MLStripper(HTMLParser):&lt;br /&gt;
def &lt;strong&gt;init&lt;/strong&gt;(self):&lt;br /&gt;
self.reset()&lt;br /&gt;
self.fed = []&lt;br /&gt;
def handle_data(self, d):&lt;br /&gt;
self.fed.append(d)&lt;br /&gt;
def get_data(self):&lt;br /&gt;
return ''.join(self.fed)&lt;/p&gt;
&lt;p&gt;tree = ET.parse('0x7df.wordpress.2015-04-25.xml')&lt;/p&gt;
&lt;p&gt;root = tree.getroot()&lt;/p&gt;
&lt;p&gt;postwords = []&lt;/p&gt;
&lt;p&gt;for child in root.iter():&lt;br /&gt;
if child.tag == 'item':&lt;br /&gt;
if child.find('{http://wordpress.org/export/1.2/}status').text ==
'publish':&lt;br /&gt;
postbody =
child.find('{http://purl.org/rss/1.0/modules/content/}encoded').text&lt;br /&gt;
s = MLStripper()&lt;br /&gt;
s.feed(postbody)&lt;br /&gt;
postwords += s.get_data().split()&lt;/p&gt;
&lt;p&gt;keywords = ' '.join([wd for wd in postwords&lt;br /&gt;
if 'http' not in wd and&lt;br /&gt;
'bg=' not in wd and&lt;br /&gt;
not wd.startswith('$') and&lt;br /&gt;
not wd.startswith('[') and&lt;br /&gt;
not wd.startswith('&amp;amp;')&lt;br /&gt;
])&lt;/p&gt;
&lt;p&gt;wordcloud = WordCloud(&lt;br /&gt;
font_path='./SaucerBB.ttf',&lt;br /&gt;
stopwords=STOPWORDS,&lt;br /&gt;
background_color='black',&lt;br /&gt;
width=1800,&lt;br /&gt;
height=1800&lt;br /&gt;
).generate(keywords)&lt;/p&gt;
&lt;p&gt;plt.imshow(wordcloud)&lt;br /&gt;
plt.axis('off')&lt;br /&gt;
plt.savefig('./my_wordpress_wordcloud_2.png', dpi=300)&lt;br /&gt;
plt.show()&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;I used the standard library light-weight
&lt;code&gt;&amp;lt;a href="https://docs.python.org/2/library/xml.etree.elementtree.html" target="_blank"&amp;gt;xml.etree.ElementTree&amp;lt;/a&amp;gt;&lt;/code&gt;
parser. I get the root of the &lt;a href="http://en.wikipedia.org/wiki/XML"&gt;XML&lt;/a&gt;
document, and iterate over its children; this is recursive, so it
descends down the tree to all nodes. Whenever I encounter a node which
has the tag &lt;code&gt;item&lt;/code&gt; (which contains the post information), I search
amongst its immediate children using the &lt;code&gt;find()&lt;/code&gt; method, to find one
with tag &lt;code&gt;{http://wordpress.org/export/1.2/}status&lt;/code&gt;, which contains the
status of the post, i.e. whether it's published, draft, etc. If it's
published (the text that the XML tag contains &lt;code&gt;== publish&lt;/code&gt;), then I
search again using &lt;code&gt;find()&lt;/code&gt; for the tag
&lt;code&gt;{http://purl.org/rss/1.0/modules/content/}encoded&lt;/code&gt;, which contains the
blog post text. I put this in the &lt;code&gt;postbody&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;The next few lines use the &lt;code&gt;class&lt;/code&gt; defined earlier on in the script -
&lt;code&gt;MLStripper()&lt;/code&gt; - to strip out the &lt;a href="http://www.w3schools.com/html/"&gt;HTML&lt;/a&gt;
tags from the blog post. (This came from
&lt;a href="//stackoverflow.com/questions/753052/strip-html-from-strings-in-python"&gt;StackOverflow&lt;/a&gt;.)
The rest of the script is essentially the same as &lt;a href="http://sebastianraschka.com/Articles/2014_twitter_wordcloud.html"&gt;Raschka's code for
Twitter&lt;/a&gt;,
tweaked a little where necessary.&lt;br /&gt;
The result is:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://0x7df.files.wordpress.com/2015/04/my_wordpress_wordcloud_21.png"&gt;&lt;img alt="my_wordpress_wordcloud_2" src="https://0x7df.files.wordpress.com/2015/04/my_wordpress_wordcloud_21.png?w=660" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The font is called Saucer BB, from
&lt;a href="http://www.1001fonts.com/saucer-bb-font.html"&gt;here&lt;/a&gt;.&lt;/p&gt;</summary><category term="api"></category><category term="html"></category><category term="python"></category><category term="twitter"></category><category term="wordcloud"></category><category term="wordpress"></category><category term="xml"></category></entry><entry><title>Python code analysis using Prospector</title><link href="http://0x7df.github.io/python-code-analysis-using-prospector.html" rel="alternate"></link><published>2015-04-11T23:32:00+01:00</published><updated>2015-04-11T23:32:00+01:00</updated><author><name>0x7df</name></author><id>tag:0x7df.github.io,2015-04-11:python-code-analysis-using-prospector.html</id><summary type="html">&lt;p&gt;A &lt;a href="https://blog.landscape.io/prospector-python-static-analysis-for-humans.html"&gt;recent blog
post&lt;/a&gt;
I came across introduced me to
&lt;a href="https://github.com/landscapeio/prospector"&gt;Prospector&lt;/a&gt;, a
&lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt;&lt;a href="http://en.wikipedia.org/wiki/Static_program_analysis"&gt;static
analysis&lt;/a&gt; tool
developed by &lt;a href="https://landscape.io/"&gt;Landscape&lt;/a&gt;. From the
&lt;a href="https://prospector.readthedocs.org"&gt;documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Prospector is a tool to analyse Python code and output information
about errors, potential problems, convention violations and
complexity.&lt;/p&gt;
&lt;p&gt;It brings together the functionality of other Python analysis tools
such as &lt;a href="http://docs.pylint.org/"&gt;Pylint&lt;/a&gt;,
&lt;a href="http://pep8.readthedocs.org/en/latest/"&gt;pep8&lt;/a&gt;, and &lt;a href="https://pypi.python.org/pypi/mccabe"&gt;McCabe
complexity&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The primary aim of Prospector is to be useful ‘out of the box’. A
common complaint of other Python analysis tools is that it takes a
long time to filter through which errors are relevant or interesting
to your own coding style. Prospector provides some default profiles,
which hopefully will provide a good starting point and will be useful
straight away, and adapts the output depending on the libraries your
project uses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So rather than configuring and individually using the various different
static analysis packages mentioned, and wading through the potentially
overwhelming output, Prospector provides a single interface to all of
them, and is set up to give a more manageable level of information
straight-away, without much user intervention. I won't repeat the sales
pitch and the basic how-to that &lt;a href="https://blog.landscape.io/prospector-python-static-analysis-for-humans.html"&gt;that
post&lt;/a&gt;
contains, but will go on from there to give a bit more information.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Cyclomatic complexity&lt;/h2&gt;
&lt;p&gt;The first thing you might come across that might not be self-evident is
the complexity rating given by the
&lt;a href="https://github.com/flintwork/mccabe"&gt;&lt;code&gt;mccabe&lt;/code&gt;&lt;/a&gt; package. E.g.:&lt;/p&gt;
&lt;p&gt;[code lang="bash"]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;prospector --strictness low&lt;br /&gt;
Messages&lt;br /&gt;
========&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;main.py&lt;br /&gt;
  Line: 13&lt;br /&gt;
    mccabe: MC0001 / run is too complex (17)&lt;/p&gt;
&lt;h1&gt;Check Information&lt;/h1&gt;
&lt;p&gt;Started: 2015-04-11 15:59:47.759944&lt;br /&gt;
       Finished: 2015-04-11 15:59:51.598176&lt;br /&gt;
     Time Taken: 3.84 seconds&lt;br /&gt;
      Formatter: grouped&lt;br /&gt;
       Profiles: default, strictness_low, strictness_medium,
strictness_high, strictness_veryhigh, no_doc_warnings,
no_test_warnings, no_member_warnings&lt;br /&gt;
     Strictness: low&lt;br /&gt;
 Libraries Used:&lt;br /&gt;
      Tools Run: dodgy, mccabe, pep8, profile-validator, pyflakes,
pylint&lt;br /&gt;
 Messages Found: 1&lt;/p&gt;
&lt;p&gt;[/code]&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;cyclomatic complexity&lt;/em&gt; metric was defined by &lt;a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1702388&amp;amp;filter%3DAND%28p_IS_Number%3A35895%29"&gt;Thomas J. McCabe in a
1976
paper&lt;/a&gt;
(the PDF of which can be found
&lt;a href="http://www.literateprogramming.com/mccabe.pdf"&gt;here&lt;/a&gt;, or reproduced in
the &lt;a href="https://books.google.co.uk/books?id=vtNWAAAAMAAJ&amp;amp;dq=%22structured%20testing%22&amp;amp;pg=PR1#v=onepage&amp;amp;q=%22structured%20testing%22&amp;amp;f=false"&gt;book "Structured Testing" which is available on Google
Books&lt;/a&gt;).
It is essentially a measure of the number of logical paths through a
piece of source code: the higher the number, the higher the complexity,
and therefore the more error-prone the code is likely to be. McCabe
suggested "10... seems like a reasonable, but not magical, upper limit".
The example given above was found to have a complexity of 17, so needs
simplifying (e.g by breaking up into more than one routine).&lt;/p&gt;
&lt;p&gt;For more detail, the McCabe paper gives a very good description which is
hard to improve on:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a program we will associate with it a directed graph that has
unique entry and exit nodes [vertices]. Each node in the graph
corresponds to a block of code in the program where the flow is
sequential and the arcs [edges] correspond to branches taken in the
program. This graph is classically known as the program control
graph... and it is assumed that each node can be reached by the entry
node and each node can reach the exit node. For example the following
is a program control graph with entry node &lt;span class="math"&gt;\( a\)&lt;/span&gt; and
exit node &lt;span class="math"&gt;\( f\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Reproduced from McCabe (1976)" src="https://books.google.co.uk/books?id=vtNWAAAAMAAJ&amp;amp;pg=PA3&amp;amp;img=1&amp;amp;zoom=3&amp;amp;hl=en&amp;amp;sig=ACfU3U2LbN62dSqC_xZCFeoYcb-COKZ7IA&amp;amp;ci=642%2C968%2C254%2C220&amp;amp;edge=0" /&gt;&lt;/p&gt;
&lt;p&gt;The following mathematical preliminaries will be needed...&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Definition 1&lt;/em&gt;: The cyclomatic number &lt;span class="math"&gt;\( V(G)\)&lt;/span&gt; of a
graph &lt;span class="math"&gt;\( G\)&lt;/span&gt; with &lt;span class="math"&gt;\( n\)&lt;/span&gt; vertices,
&lt;span class="math"&gt;\( e\)&lt;/span&gt; edges and &lt;span class="math"&gt;\( p\)&lt;/span&gt; connected
components is&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$ V(G) = e - n + p $$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Theorem 1&lt;/em&gt;: In a strongly connected graph &lt;span class="math"&gt;\( G\)&lt;/span&gt; the
cyclomatic number is equal to the maximum number of linearly
independent circuits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Note here that at this stage we are concerned with &lt;em&gt;circuits&lt;/em&gt; - i.e.
closed loops that start at a given node and return back to that same
node - rather than &lt;em&gt;paths&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Theorem 1 is applied to &lt;span class="math"&gt;\( G\)&lt;/span&gt; in the following way.
Imagine that the exit node &lt;span class="math"&gt;\( f\)&lt;/span&gt; branches back to the
entry node &lt;span class="math"&gt;\( a\)&lt;/span&gt;. The control graph &lt;span class="math"&gt;\( G\)&lt;/span&gt;
is now strongly connected (there is a path joining any
pair of arbitrary distinct vertices) so Theorem 1 applies. Therefore
the maximum number of linearly independent circuits in &lt;span class="math"&gt;\( G\)&lt;/span&gt;
is &lt;span class="math"&gt;\( 9 - 6 + 2\)&lt;/span&gt;. For example one could
choose the following 5 independent circuits in &lt;span class="math"&gt;\( G\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$ B1: (abefa), (beb), (abea), (acfa), (adcfa) $$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;It follows that &lt;span class="math"&gt;\( B1\)&lt;/span&gt; forms a basis for the set of
all circuits in &lt;span class="math"&gt;\( G\)&lt;/span&gt; and any path through &lt;span class="math"&gt;\( G\)&lt;/span&gt;
can be expressed as a linear combination of circuits from
&lt;span class="math"&gt;\( B1\)&lt;/span&gt;. For instance the path &lt;span class="math"&gt;\( (abeabebebef)\)&lt;/span&gt;
is expressible as &lt;span class="math"&gt;\( (abea) + 2(beb) + (abefa)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To see how this works it's necessary to number the edges on &lt;span class="math"&gt;\( G\)&lt;/span&gt;
as in:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Reproduced from McCabe, 1976." src="https://books.google.co.uk/books?id=vtNWAAAAMAAJ&amp;amp;pg=PA4&amp;amp;img=1&amp;amp;zoom=3&amp;amp;hl=en&amp;amp;sig=ACfU3U2LMlgVCsIny0X682Rs8LVIkP0WqA&amp;amp;ci=165%2C387%2C235%2C207&amp;amp;edge=0" /&gt;&lt;/p&gt;
&lt;p&gt;Now for each member of the basis &lt;span class="math"&gt;\( B1\)&lt;/span&gt; associate a
vector as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Reproduced from McCabe, 1976." src="https://books.google.co.uk/books?id=vtNWAAAAMAAJ&amp;amp;pg=PA4&amp;amp;img=1&amp;amp;zoom=3&amp;amp;hl=en&amp;amp;sig=ACfU3U2LMlgVCsIny0X682Rs8LVIkP0WqA&amp;amp;ci=66%2C638%2C279%2C134&amp;amp;edge=0" /&gt;&lt;/p&gt;
&lt;p&gt;The path &lt;span class="math"&gt;\( (abea(be)^3fa)\)&lt;/span&gt; corresponds to the
vector &lt;span class="math"&gt;\( 2004200111\)&lt;/span&gt; and the vector addition of
&lt;span class="math"&gt;\( (abefa)\)&lt;/span&gt;, &lt;span class="math"&gt;\( 2(beb)\)&lt;/span&gt; and
&lt;span class="math"&gt;\( (abea)\)&lt;/span&gt; yields the desired result.&lt;/p&gt;
&lt;p&gt;In using Theorem 1 one can choose a basis set of circuits that
correspond to paths through the program. The set &lt;span class="math"&gt;\( B2\)&lt;/span&gt;
is a basis of program paths.&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$ B2: (abef), (abeabef), (abebef), (acf), (adcf) $$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Linear combination of paths in &lt;span class="math"&gt;\( B2\)&lt;/span&gt; will also
generate any path. For example:&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$ (abea(be)^3f) = 2(abebef) - (abef) $$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$ (a(be)^2(abef) = (a(be)^2f) + (abeabef) - (abef) $$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;The overall strategy will be to measure the complexity of a program by
computing the number of linearly independent paths &lt;span class="math"&gt;\( V(G)\)&lt;/span&gt;,
control the size of programs by setting an upper limit
to &lt;span class="math"&gt;\( V(G)\)&lt;/span&gt; (instead of using just physical size),
and use the cyclomatic complexity as the basis for a testing
methodology.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[caption id="attachment_450" align="alignleft" width="178"]&lt;a href="https://0x7df.files.wordpress.com/2015/04/example_mccabe_graph.png"&gt;&lt;img alt="Example
mccabe graph
output" src="https://0x7df.files.wordpress.com/2015/04/example_mccabe_graph.png?w=178" /&gt;&lt;/a&gt;
Example mccabe graph output[/caption]&lt;/p&gt;
&lt;p&gt;If you want to run &lt;code&gt;mccabe&lt;/code&gt; separately from &lt;code&gt;prospector&lt;/code&gt; you can do,
using:&lt;/p&gt;
&lt;p&gt;[code lang="bash"]  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python -m mccabe mysourcefile.py&lt;br /&gt;
('If 209', 2)&lt;br /&gt;
("13:1: 'run'", 8)&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can add the &lt;code&gt;-d&lt;/code&gt; option (documented
&lt;a href="http://nedbatchelder.com/blog/200803/python_code_complexity_microtool.html"&gt;here&lt;/a&gt;)
to produce output that can be passed to the
&lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt; program
&lt;a href="http://www.graphviz.org/pdf/dotguide.pdf"&gt;dot&lt;/a&gt;, which will plot the
graph. I.e.:&lt;/p&gt;
&lt;p&gt;[code lang="bash"]  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python -m mccabe -d example.py | \&lt;br /&gt;
dot -Tpng -o example.png&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;produces something like the graph shown to the left.&lt;/p&gt;
&lt;p&gt;As well as using the cyclomatic complexity as a metric of whether a
particular piece of source code needs simplifying, it can also give an
indication of the number of tests that are required. If the number of
tests is less than the complexity metric, then clearly there must be
some paths through that are not being tested. Obviously, it doesn't
necessarily follow that, if the number of tests is equal to or greater
than the complexity, then all paths &lt;em&gt;are&lt;/em&gt; being tested - more than one
test might be following a particular logical path. So having
&lt;span class="math"&gt;\( V(G)\)&lt;/span&gt; tests for a particular routine &lt;span class="math"&gt;\( G\)&lt;/span&gt;
is necessary but not sufficient to ensure full coverage of all the
paths; but it seems like a good start.&lt;/p&gt;
&lt;h2&gt;Fine-tuning using profiles in Prospector&lt;/h2&gt;
&lt;p&gt;Probably one of the most useful aspects of Prospector is the ability to
fine-tune the warnings that are issued. For instance, once the
strictness level is up to medium or above, you might start to get a lot
of warnings from Pylint about invalid constant names:&lt;/p&gt;
&lt;p&gt;[code]&lt;br /&gt;
example.py&lt;br /&gt;
Line: 1&lt;br /&gt;
pylint: invalid-name / Invalid constant name "nmats"&lt;br /&gt;
Line: 17&lt;br /&gt;
pylint: invalid-name / Invalid constant name "dcoeff"&lt;br /&gt;
Line: 21&lt;br /&gt;
pylint: invalid-name / Invalid constant name "tpower"&lt;br /&gt;
Line: 23&lt;br /&gt;
pylint: invalid-name / Invalid constant name "tmp0"&lt;br /&gt;
...&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://www.python.org/dev/peps/pep-0008"&gt;PEP8 style guide&lt;/a&gt;
suggests constants should be in upper case; I'm happy with this rule but
in most cases that were identified for a particular project I used a
trial run, I didn't regard the variable as a constant (e.g. like
&lt;span class="math"&gt;\( \pi\)&lt;/span&gt;, &lt;span class="math"&gt;\( c\)&lt;/span&gt;, &lt;span class="math"&gt;\( h\)&lt;/span&gt;,
etc.), but a variable that happens not to change - in a lot of the cases
just because the code is incomplete and, at some point down the line,
these will end up changing.&lt;/p&gt;
&lt;p&gt;When we move to the &lt;code&gt;veryhigh&lt;/code&gt; strictness level, another example that
comes up is trailing whitespace. I want to remove trailing whitespace
from lines of code; but because my editor automatically indents, &lt;em&gt;blank&lt;/em&gt;
lines also get indented to the same level as the most recent non-blank
line. This whitespace on otherwise blank lines counts as trailing
whitespace, so I get far too many warning messages.&lt;/p&gt;
&lt;p&gt;Thirdly, classes that have too few (fewer than two) public methods are
warned against; &lt;a href="http://stackoverflow.com/questions/14027417/what-does-pylints-too-few-public-methods-message-mean"&gt;the advice is that classes shouldn't be used for data
storage, but should include
functions&lt;/a&gt;.
If the only purpose is data storage, then a data structure  like a
dictionary is more appropriate. However, again because of the
work-in-progress status of the code being analysed, I've defined certain
classes that currently only register data, but I expect at some point
will include methods. So in the meantime I want to turn this check off,
for the moment at least.&lt;/p&gt;
&lt;p&gt;The fine-tuning is done using profiles. A profile is just a
&lt;a href="http://yaml.org/"&gt;YAML&lt;/a&gt;file with some configuration information, so you
can give different projects different rule sets by giving them their own
configuration file. An example is:&lt;/p&gt;
&lt;p&gt;[code]&lt;br /&gt;
strictness: veryhigh&lt;br /&gt;
ignore-paths: QA&lt;br /&gt;
pylint:&lt;br /&gt;
disable:&lt;br /&gt;
- invalid-name&lt;br /&gt;
- trailing-whitespace&lt;br /&gt;
- too-few-public-methods&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The really nice part is that configurations can inherit from other
configurations. For example, Prospector's different &lt;code&gt;--strictness&lt;/code&gt;
options are really just different pre-defined profiles, and the example
above has been set up to inherit from the &lt;code&gt;--strictness high&lt;/code&gt; profile.
The project-specific tweaks are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ignore the directory called `QA` and its contents (which in this
    project contains temporary/intermediate files). This can also be
    achieved by using `--ignore-paths QA` on the command line.&lt;/li&gt;
&lt;li&gt;Disable the `invalid-name` messages from Pylint.&lt;/li&gt;
&lt;li&gt;Disable the `trailing-whitespace` messages from Pylint&lt;/li&gt;
&lt;li&gt;Disable the `too-few-public-methods` messages from Pylint&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Adding additional tools&lt;/h2&gt;
&lt;p&gt;As well as the default tools (Pylint,
&lt;a href="https://pypi.python.org/pypi/pep8"&gt;pep8&lt;/a&gt;,
&lt;a href="https://pypi.python.org/pypi/pyflakes"&gt;pyflakes&lt;/a&gt;, mccabe,
&lt;a href="https://github.com/landscapeio/dodgy"&gt;dodgy&lt;/a&gt; and profile_validator),
additional tools can be turned on either via the command line or by
adding them to a profile. The useful extra options are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/pep257"&gt;pep257&lt;/a&gt;, which checks that
    docstrings conform to the &lt;a href="https://www.python.org/dev/peps/pep-0257/"&gt;PEP257 docstring conventions
    guide&lt;/a&gt;. Use `--with-tool
    pep257` on the command line, or add `run: true` to a `pep257:`
    section in a profile file.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/vulture"&gt;vulture&lt;/a&gt;, which checks for
    'dead code' (unused variables, functions, classes, etc.). This
    requires installation first, via `pip install
    prospector[with_vulture]`. (NB this syntax doesn't work in a &lt;a href="http://zsh.sourceforge.net/"&gt;Z
    shell&lt;/a&gt;.)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/pyroma"&gt;pyroma&lt;/a&gt;, used for checking
    that Python packaging best practices are being followed. Requires
    `pip install prospector[with_pyroma]`. Note that using pyroma
    implies the use of pep257.&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="cyclomatic complexity"></category><category term="graph theory"></category><category term="mccabe"></category><category term="pep8"></category><category term="prospector"></category><category term="pylint"></category><category term="python"></category><category term="static analysis"></category><category term="yaml"></category></entry><entry><title>Converting from Doxygen to WordPress</title><link href="http://0x7df.github.io/converting-from-doxygen-to-wordpress.html" rel="alternate"></link><published>2015-03-29T19:27:00+01:00</published><updated>2015-03-29T19:27:00+01:00</updated><author><name>0x7df</name></author><id>tag:0x7df.github.io,2015-03-29:converting-from-doxygen-to-wordpress.html</id><summary type="html">&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;I write code documentation in &lt;a href="www.doxygen.org/"&gt;Doxygen&lt;/a&gt;, and in some
cases include a fair amount of information about the mathematical theory
of the problem that the code is solving. It seemed worthwhile posting
the same content on &lt;a href="https://wordpress.com"&gt;Wordpress&lt;/a&gt;. However, the
syntax isn't 100% interchangeable, despite both applications supporting
&lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt;. This is mainly
because Doxygen extends Markdown by providing &lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html"&gt;a large range of special
commands&lt;/a&gt;,
which begin with a &lt;code&gt;/&lt;/code&gt; or a &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The bulk of the changes that need to be made are to the equations.
Doxygen and WordPress both allow 
&lt;a href="http://www.latex.org"&gt;&lt;img alt="\LaTeX" src="https://s0.wp.com/latex.php?latex=%5CLaTeX&amp;amp;fg=000" title="\LaTeX" /&gt;&lt;/a&gt;
equations; Doxygen by actually
calling &lt;img alt="\LaTeX" src="https://s0.wp.com/latex.php?latex=%5CLaTeX&amp;amp;fg=000" title="\LaTeX" /&gt;
to generate
&lt;a href="en.wikipedia.org/wiki/Portable_Network_Graphics"&gt;PNG&lt;/a&gt;-format images
which it embeds in the &lt;a href="www.w3schools.com/html/"&gt;HTML&lt;/a&gt;files that it
generates, and WordPress by using one of &lt;a href="https://wordpress.org/plugins/search.php?q=latex"&gt;various
plug-ins&lt;/a&gt; (see
documentation &lt;a href="https://en.support.wordpress.com/latex/"&gt;here&lt;/a&gt;). However,
while the code for the actual equation is identical in both, being
standard
&lt;a href="http://www.ams.org/publications/authors/tex/amsmath"&gt;amsmath&lt;/a&gt;-style
&lt;a href="http://www.latex.org"&gt;&lt;img alt="\LaTeX" src="https://s0.wp.com/latex.php?latex=%5CLaTeX&amp;amp;fg=000" title="\LaTeX" /&gt;&lt;/a&gt;,
the delimiters that identify it as maths and separate it from the body
of the text are different. References also need to be handled
differently.&lt;/p&gt;
&lt;p&gt;[caption id="" align="alignright" width="404"]&lt;img alt="xkcd:
Automation" src="http://imgs.xkcd.com/comics/automation.png" /&gt; xkcd: Automation
- http://imgs.xkcd.com/comics/automation.png[/caption]&lt;/p&gt;
&lt;p&gt;Rather than do the conversion by hand, I knocked up a simple
&lt;a href="http://python.org"&gt;Python&lt;/a&gt; script to do it (and in doing so risked
falling into the trap of spending more time writing code to automate the
task than I would have spent doing it manually) using simple &lt;a href="www.regular-expressions.info/"&gt;regular
expressions&lt;/a&gt; in some cases. This post
describes how the script works, so along the way we'll learn a bit of
Python, something about regular expressions, and a bit about Doxygen and
WordPress syntax.&lt;/p&gt;
&lt;p&gt;Let's jump straight in. The script is called from the command line:&lt;/p&gt;
&lt;p&gt;[code lang="bash"]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python dox2wp.py /path/to/doxygen/data/example.md&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[/code]&lt;/p&gt;
&lt;p&gt;The script is called &lt;code&gt;dox2wp.py&lt;/code&gt;, and we've passed the full path to a
Doxygen Markdown file called &lt;code&gt;example.md&lt;/code&gt; as an argument to the Python
script.&lt;/p&gt;
&lt;h2&gt;Main script&lt;/h2&gt;
&lt;p&gt;The first part of the script looks like this:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
if &lt;strong&gt;name&lt;/strong&gt; == "&lt;strong&gt;main&lt;/strong&gt;":&lt;/p&gt;
&lt;p&gt;args = sys.argv[1:]&lt;/p&gt;
&lt;p&gt;reffile = '/default/path/to/references.md'&lt;/p&gt;
&lt;p&gt;for arg in args:&lt;br /&gt;
errmsg = processdox(arg,reffile)&lt;br /&gt;
for msg in errmsg:&lt;br /&gt;
print msg&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The first line - &lt;code&gt;if __name__ == "__main__":&lt;/code&gt; - is a fairly standard
Python construct that checks that the module being executed has been
called from the command-line or interpreter directly, and not by some
other Python module or function. &lt;a href="http://stackoverflow.com/a/419185/3832350"&gt;This
answer&lt;/a&gt; on
&lt;a href="http://stackoverflow.com"&gt;StackOverflow&lt;/a&gt;gives more details. The next
line retrieves the arguments that were passed in to the Python script
using the &lt;code&gt;sys&lt;/code&gt; module's &lt;code&gt;argv&lt;/code&gt; function  (this assumes &lt;code&gt;sys&lt;/code&gt; has been
imported using &lt;code&gt;import sys&lt;/code&gt; somewhere prior to this statement; usually
at the very top of the file). The &lt;code&gt;argv&lt;/code&gt; function returns the arguments
as a list; the zeroth element corresponds to the name of the script, so
we ignore that and just get elements 1 through to the end of the list
and store them in a new list called &lt;code&gt;args&lt;/code&gt;. You can find documentation
for the &lt;code&gt;sys&lt;/code&gt; module &lt;a href="https://docs.python.org/2/library/sys.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Next we define a hard-wired path to a file, which we'll come back to
later.&lt;/p&gt;
&lt;p&gt;The next chunk of code is where the main business happens. We loop over
all the items in &lt;code&gt;args&lt;/code&gt;, each of which is assumed to be a Markdown file
we want to process. For each, we call the function &lt;code&gt;processdox&lt;/code&gt;, passing
in both the path to the file, and the hard-wired path mentioned above.
The &lt;code&gt;processdox&lt;/code&gt; function returns a list of error messages, which we
bind to the variable &lt;code&gt;errmsg&lt;/code&gt;. The last action in this script is to loop
over the error messages returned by the processing function, and print
them to the screen.&lt;/p&gt;
&lt;h2&gt;Function `processdox`&lt;/h2&gt;
&lt;p&gt;The body of the &lt;code&gt;processdox&lt;/code&gt; function is given below:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
def processdox(filename,reffile):&lt;/p&gt;
&lt;p&gt;errmsg = checkfile(filename)&lt;/p&gt;
&lt;p&gt;if len(errmsg) == 0:&lt;br /&gt;
processfile(filename,reffile=reffile)&lt;/p&gt;
&lt;p&gt;return errmsg&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The first line is the function definition, which also specifies the
arguments that function accepts: &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;reffile&lt;/code&gt;. Then, two
functions are called: the first, &lt;code&gt;checkfile&lt;/code&gt;, does some error-checking,
and the second, &lt;code&gt;processfile&lt;/code&gt;, does the main work - but only if the
length of the list &lt;code&gt;errmsg&lt;/code&gt; is zero (i.e. it contains no data, which is
a way of checking that &lt;code&gt;checkfile&lt;/code&gt; didn't return any error messages).&lt;/p&gt;
&lt;h2&gt;Error checking&lt;/h2&gt;
&lt;p&gt;Let's see the file-checking function &lt;code&gt;checkfile&lt;/code&gt; next:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
def checkfile(filename):&lt;/p&gt;
&lt;p&gt;errmsg = []&lt;/p&gt;
&lt;p&gt;filebase, fileext = os.path.splitext(filename)&lt;/p&gt;
&lt;p&gt;if fileext != '.md':&lt;br /&gt;
errmsg.append(filename+' is not Markdown')&lt;/p&gt;
&lt;p&gt;if not os.path.isfile(filename):&lt;br /&gt;
errmsg.append(filename+' does not exist or is&lt;br /&gt;
not a file')&lt;/p&gt;
&lt;p&gt;return errmsg&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;This first declares the &lt;code&gt;errmsg&lt;/code&gt; variable as an empty list, and then
uses the standard &lt;code&gt;os.path&lt;/code&gt; module's &lt;code&gt;splitext&lt;/code&gt; function, which returns
the file's extension, and everything up to that extension (as a tuple),
which we write into &lt;code&gt;fileext&lt;/code&gt; and &lt;code&gt;filebase&lt;/code&gt;. Doing this allows us to
check easily that the file extension is &lt;code&gt;.md&lt;/code&gt;. The next check is that
the filename given refers to something that exists and is a file (e.g.
as opposed to a directory), using the &lt;code&gt;isfile()&lt;/code&gt; function. Documentation
for &lt;code&gt;os.path&lt;/code&gt; can be found
&lt;a href="https://docs.python.org/2/library/os.path.html#module-os.path"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Notice that all we do on finding an error is to append an error message
to the previously defined list, using &lt;code&gt;errmsg.append()&lt;/code&gt;. The reason for
this is that, although it scarcely matters for this almost trivial
application, I find it good practice to let a piece of code go on for as
long as it can after encountering errors, because there may be further
errors that will get picked up subsequently. If it stopped immediately,
the user would fix that error, and start it again, whereupon the next
error encountered would cause it to bail out again. For software with
complicated input this could go on for a long time and cause a lot of
frustration. The behaviour here, however, is to keep going and identify
as many errors as possible before stopping, so we minimise the number of
iterations the user will have to go through to fix everything.&lt;/p&gt;
&lt;p&gt;For example, if we call:&lt;/p&gt;
&lt;p&gt;[code lang="bash"]  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python dox2wp.py isnotmarkdown.txt doesnotexist.md \&lt;br /&gt;
existsbutisafolder.md realmarkdown.md&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;then we get:&lt;/p&gt;
&lt;p&gt;[code]&lt;br /&gt;
isnotmarkdown.txt is not Markdown&lt;br /&gt;
doesnotexist.md does not exist or is not a file&lt;br /&gt;
existsbutisafolder.md does not exist or is not a file&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;Note there's no error message referring to &lt;code&gt;realmarkdown.md&lt;/code&gt;, which
meets the criteria and so is processed successfully.&lt;/p&gt;
&lt;p&gt;It's important to understand that this isn't the same as being
fault-tolerant or trying to recover from the errors. In principle, as
soon as the user does something that doesn't seem to fit in with the way
a piece of code is intended to work, we should stop and let the user
know; trying to recover starts to get into the realm of making
assumptions about what the user wants. All we're doing here is
continuing to progress through the &lt;em&gt;error-checking&lt;/em&gt; when an error is
encountered; as soon as one is, the actual processing is prevented by
the &lt;code&gt;if&lt;/code&gt; statement around the call to &lt;code&gt;processfile&lt;/code&gt;. We do allow the
application to continue to the next Markdown file if an error was
encountered previously, but since processing of each file is completely
independent, this seems safe enough.&lt;/p&gt;
&lt;p&gt;Of course, all this is total overkill for what we're trying to do, but
is useful to illustrate the principles in a simple application.&lt;/p&gt;
&lt;h2&gt;The actual format conversion part&lt;/h2&gt;
&lt;h3&gt;Preamble&lt;/h3&gt;
&lt;p&gt;Function &lt;code&gt;processfile&lt;/code&gt; executes the real work. This is somewhat longer
so we'll deal with it in sections. It starts with:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
def processfile(filename,reffile='references.md'):&lt;/p&gt;
&lt;p&gt;fi = open(filename,'r')&lt;br /&gt;
fo = open(filename+'.txt','w')&lt;br /&gt;
fr = open(reffile,'r')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;After the function definition, which like the previous one we saw
defines the input arguments &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;reffile&lt;/code&gt; (but with the
addition that the &lt;code&gt;reffile&lt;/code&gt; variable defaults to &lt;code&gt;references.md&lt;/code&gt; if no
argument is passed in), the next three lines open some files. &lt;code&gt;filename&lt;/code&gt;
and &lt;code&gt;reffile&lt;/code&gt; are opened as read-only (with some obvious error-checking
around &lt;code&gt;reffile&lt;/code&gt; clearly missing). A new file called &lt;code&gt;reffile + '.txt'&lt;/code&gt;
is opened as writeable, and this will contain the output; the filename
will be the same as the input but with &lt;code&gt;.txt&lt;/code&gt; appended, e.g.
&lt;code&gt;example.md.txt&lt;/code&gt; if the input was &lt;code&gt;example.md&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The next stage is to define some regular expressions that will get used
later; we define them here rather than nearer to where they get used
because their use will be inside a loop, and there's no point
re-defining them every time the loop is executed, because they're always
the same.&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
p1 = re.compile('@f\&lt;span class="math"&gt;\([^@]*@f\\\)&lt;/span&gt;')&lt;br /&gt;
p2 = re.compile('@ref [^"]&lt;em&gt; "[^"]&lt;/em&gt;"')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;We'll come back to these when they're needed.&lt;/p&gt;
&lt;p&gt;The final part of the pre-amble involved setting up a counter and an
empty list for the references, again which we'll come to when we need
them.&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
refnum = 1&lt;br /&gt;
footnotes = []&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;In the next stage we enter the loop over individual lines in the input
file, which Python implements very simply as &lt;code&gt;for line in fi:&lt;/code&gt;, with
&lt;code&gt;line&lt;/code&gt; being the variable name into which each successive line is
placed, and &lt;code&gt;fi&lt;/code&gt; just being the pointer to the opened text file.&lt;/p&gt;
&lt;p&gt;The first text-processing operation is to replace &amp;lt; and &amp;gt; with their
HTML equivalents: &lt;code&gt;&amp;amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;amp;gt;&lt;/code&gt;, respectively.&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
for line in fi:&lt;/p&gt;
&lt;p&gt;# Some of the later changes insert "&amp;lt;" and "&amp;gt;" so do&lt;br /&gt;
# these as early as possible&lt;br /&gt;
line = line.replace('&amp;lt;','&amp;lt;')&lt;br /&gt;
line = line.replace('&amp;gt;','&amp;gt;')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The reason for this is that, for this to work overall, the final output
needs to be copied and pasted into WordPress's HTML editor, rather than
the Visual editor. Consequently, there's a risk that any &amp;lt; and &amp;gt;
symbols appearing in mathematical formulae will get interpreted as
delimiters for an HTML tag. E.g. if:&lt;/p&gt;
&lt;div class="math"&gt;$$ a &amp;lt; b$ and also $ b &amp;gt; c $$&lt;/div&gt;
&lt;p&gt;appeared on a single line then the string:&lt;/p&gt;
&lt;div class="math"&gt;$$ &amp;lt; b$ and also $ b &amp;gt; $$&lt;/div&gt;
&lt;p&gt;would get interpreted as an HTML tag (and ignored as not recognised),
leaving:&lt;/p&gt;
&lt;div class="math"&gt;$$ a c $$&lt;/div&gt;
&lt;p&gt;I wasn't expecting this, at least not when the &amp;lt; and &amp;gt; symbols were
safely inside the correct &lt;code&gt;$latex&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; delimiters identifying them
as maths - but it happened, which seems like a flaw in the WordPress
parsing.&lt;/p&gt;
&lt;h3&gt;Special commands&lt;/h3&gt;
&lt;p&gt;Subsequently, we remove some of the Doxygen special commands:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
# Remove the table of contents special command&lt;br /&gt;
line = line.replace('\\tableofcontents','')&lt;/p&gt;
&lt;p&gt;# Replace the Doxygen special commands for sections&lt;br /&gt;
# with Markdown&lt;br /&gt;
if '\section' in line:&lt;br /&gt;
fields = line.split()&lt;br /&gt;
line = '# ' + ' '.join(fields[2:])&lt;br /&gt;
if '\subsection' in line:&lt;br /&gt;
fields = line.split()&lt;br /&gt;
line = '## ' + ' '.join(fields[2:])&lt;br /&gt;
if '\subsubsection' in line:&lt;br /&gt;
fields = line.split()&lt;br /&gt;
line = '### ' + ' '.join(fields[2:])&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The first special command is &lt;code&gt;\tableofcontents&lt;/code&gt;, which appears on its
own and causes Doxygen to automatically insert a contents table into the
rendered page at that location. We strip this out by replacing it with
an empty string, using the &lt;code&gt;replace&lt;/code&gt; string method.&lt;/p&gt;
&lt;p&gt;Next are &lt;code&gt;\section&lt;/code&gt;, &lt;code&gt;\subsection&lt;/code&gt; and &lt;code&gt;\subsubsection&lt;/code&gt;. Each of these
special commands is followed by two arguments: first an identifying tag,
which can then be used elsewhere in the Doxygen pages to create a link
to this section, followed by the actual title of the section, e.g.:&lt;/p&gt;
&lt;p&gt;[code]&lt;br /&gt;
\subsection introdoxy Introduction to Doxygen&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;We don't care about the ID tag, but we want to keep the title and retain
it at the same location as the section title in the WordPress post. To
do this we split the line into a list of tokens, separated by
whitespace, using &lt;code&gt;line.split()&lt;/code&gt;. The resulting list, in &lt;code&gt;fields&lt;/code&gt;, would
look like this for the example above if we printed it out:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
['\\subsection', 'introdoxy', 'Introduction', 'to', 'Doxygen']&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The idea is to discard the first two elements and keep the rest, joining
them back together into a string, and stripping out the quotation marks.&lt;/p&gt;
&lt;p&gt;[code]&lt;br /&gt;
line = '## ' + ' '.join(fields[2:])&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;Here the &lt;code&gt;string.join(list)&lt;/code&gt; syntax in Python joins all the elements of
&lt;code&gt;list&lt;/code&gt; together into a single string, using &lt;code&gt;string&lt;/code&gt; as the delimiter.
Hence in our example, &lt;code&gt;' '.join(fields[2:])&lt;/code&gt; would yield
&lt;code&gt;Introduction to Doxygen&lt;/code&gt;, and we prepend &lt;code&gt;##&lt;/code&gt; to this string to turn it
into standard Markdown format for a level 2 section header.&lt;/p&gt;
&lt;p&gt;There's probably a more compact way to deal with the multiple cases
(i.e. &lt;code&gt;\section&lt;/code&gt;, &lt;code&gt;\subsection&lt;/code&gt;, etc.) involving counting how many times
the string &lt;code&gt;sub&lt;/code&gt; appears and prepending the appropriate number of hashes
accordingly; but for only three cases, writing them out explicitly isn't
difficult, and leads to easier-to-understand code.&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;The next section of code deals with references. In Doxygen, we insert
references into the main body of the text like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@ref ref01 &amp;quot;Fick (1855)&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(or we could use &lt;code&gt;\ref&lt;/code&gt; instead of &lt;code&gt;@ref&lt;/code&gt;). Elsewhere, there would be a
references section - in this case in a separate file called
&lt;code&gt;references.md&lt;/code&gt;, which is why we've previously seen that file being
hard-wired in the main script and then passed in to this function as an
argument. In the references section, there would be an entry like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-# \anchor ref01 Fick, A, 1855. On liquid diffusion. The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science, X, 30-39.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The initial &lt;code&gt;-#&lt;/code&gt; is to create a numbered list, and the &lt;code&gt;\anchor ref01&lt;/code&gt;
creates an anchor that the earlier &lt;code&gt;@ref ref01&lt;/code&gt; syntax can link to. The
remainder is the text that appears in the references section.&lt;/p&gt;
&lt;p&gt;What we want to do is replace the in-line reference with a link to a
footnote, and use the long reference text as the footnote.&lt;/p&gt;
&lt;p&gt;For an individual references, the code that does this looks like this:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
# References&lt;/p&gt;
&lt;p&gt;refidstr = 'fn'+str(refnum)&lt;br /&gt;
refnum += 1&lt;/p&gt;
&lt;p&gt;fields = istr.split()&lt;br /&gt;
reftxt = " ".join(fields[2:]).strip('"')&lt;/p&gt;
&lt;p&gt;ostr = '&lt;a href="\#'+refidstr+'"&gt;'+reftxt+'&lt;/a&gt;'&lt;br /&gt;
line = line.replace(istr,ostr)&lt;/p&gt;
&lt;p&gt;doxref = fields[1]&lt;br /&gt;
for refline in fr:&lt;br /&gt;
if doxref in refline:&lt;br /&gt;
reffull = ' '.join(refline.strip().split()[3:])&lt;br /&gt;
break&lt;br /&gt;
footnotes.append('&lt;a name="'+refidstr+'"&gt;'+reffull+'&lt;/a&gt;')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;Although you don't see it here, the Doxygen text containing the in-line
reference is contained in &lt;code&gt;istr&lt;/code&gt; - we'll explain how it got there
shortly. The first thing we do is create a unique string for the anchor
that will be used as the ID for the footnote; i.e. if the anchor is
&lt;code&gt;fn1&lt;/code&gt;, then the inline reference will be:&lt;/p&gt;
&lt;p&gt;[code lang="html"]&lt;br /&gt;
&lt;a href="fn1"&gt;Fick (1855)&lt;/a&gt;&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;and the footnote would be:&lt;/p&gt;
&lt;p&gt;[code lang="html"]&lt;br /&gt;
&lt;a name="fn1"&gt;Fick, A, 1855. On liquid diffusion...&lt;/a&gt;&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;We have previously set up a counter for the references we discover,
which was &lt;code&gt;refnum&lt;/code&gt;, so the code &lt;code&gt;refidstr = 'fn'+str(refnum)&lt;/code&gt; will
create &lt;code&gt;fn1&lt;/code&gt; for the first reference, &lt;code&gt;fn2&lt;/code&gt; for the second, etc. You can
see that &lt;code&gt;refnum&lt;/code&gt; is incremented by 1 in the next line of the code
fragment above to ensure this.&lt;/p&gt;
&lt;p&gt;Next, we want to extract the text for the in-line reference ("Fick
(1855)" in our example), for which we use the same kind of trick as we
did for the section headings. The only difference here is that we have
to add the &lt;code&gt;strip('"')&lt;/code&gt; function to strip off the quotation marks.&lt;/p&gt;
&lt;p&gt;At this point we have enough information to construct the new text for
the in-line reference:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
ostr = '&lt;a href="\#'+refidstr+'"&gt;'+reftxt+'&lt;/a&gt;'&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;and replace the original string with the new one:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
line = line.replace(istr,ostr)&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;There's one final job; we have to create the footnote and put it at the
bottom of the page. We'll store it in a list called &lt;code&gt;footnotes&lt;/code&gt; in the
interim, and then write the list out after all the other processing has
been finished, so it appears in its proper place at the bottom of the
page.&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
doxref = fields[1]&lt;br /&gt;
for refline in fr:&lt;br /&gt;
if doxref in refline:&lt;br /&gt;
reffull = ' '.join(refline.strip().split()[3:])&lt;br /&gt;
break&lt;br /&gt;
footnotes.append('&lt;a name="'+refidstr+'"&gt;'+reffull+'&lt;/a&gt;')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;So what is this doing? We know the text that Doxygen is using - &lt;code&gt;ref01&lt;/code&gt;
- in our example, because we can extract it from the second token of the
&lt;code&gt;istr&lt;/code&gt; line (where the first token is just the &lt;code&gt;@ref&lt;/code&gt; code). Then we
have to search line-by-line through the reference file, &lt;code&gt;fr&lt;/code&gt;, until we
find a line that contains the string we're after - this will cause
&lt;code&gt;if doxref in refline&lt;/code&gt; to return true. We know this is the right line,
so we can extract the long text of the reference into &lt;code&gt;reffull&lt;/code&gt; using
the same &lt;code&gt;split&lt;/code&gt; then &lt;code&gt;join&lt;/code&gt; technique as we've seen before, starting at
the fourth token (the first three being &lt;code&gt;-#&lt;/code&gt;, &lt;code&gt;\anchor&lt;/code&gt; and &lt;code&gt;ref01&lt;/code&gt;, all
of which we want to discard).&lt;/p&gt;
&lt;p&gt;The real code, however, is a bit more complex; firstly because we need
to find the appropriate text strings in our Doxygen code before we can
format them (recall we haven't explained how &lt;code&gt;istr&lt;/code&gt; gets defined yet),
and also because there might be more than one reference on one line, so
we have to deal with that. We do this via regular expressions, which
first requires that the Python &lt;code&gt;re&lt;/code&gt; module is imported (documented
&lt;a href="https://docs.python.org/2/library/re.html"&gt;here&lt;/a&gt;). Once it is, we can
compile a regular expression using the code we saw earlier but didn't
explain:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
p2 = re.compile('@ref [^"]&lt;em&gt; "[^"]&lt;/em&gt;"')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The regular expression is the bit inside the single quotes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@ref [^&amp;quot;]* &amp;quot;[^&amp;quot;]*&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and the &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; characters are special characters that
have particular meanings in the regular expression language. The caret,
&lt;code&gt;^&lt;/code&gt;, is a &lt;code&gt;not&lt;/code&gt; operator, so &lt;code&gt;^"&lt;/code&gt; means not the quotation mark
character. Using &lt;code&gt;[ ]&lt;/code&gt; defines a set of characters that are allowed, so
for example &lt;code&gt;[aeiou]&lt;/code&gt; would match any vowel character. So &lt;code&gt;[^"]&lt;/code&gt; means
any character from the set of characters that are not the quotation mark
&lt;code&gt;"&lt;/code&gt;. Finally, the &lt;code&gt;*&lt;/code&gt; character means match any number of whatever went
previously. Hence, for example, &lt;code&gt;a*&lt;/code&gt; would match &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;aa&lt;/code&gt;, &lt;code&gt;aaa&lt;/code&gt;, etc.
Putting all this together, the regular expression &lt;code&gt;[^"]*&lt;/code&gt;, which appears
twice, means match any string of any length that doesn't contain a
quotation mark. The reason we need to specify that the string shouldn't
contain quotation marks is that these are used as delimiters, to
surround the in-line text of the reference. If we could guarantee that
quotation marks would never appear elsewhere on the same line, it
wouldn't matter; but we can't.&lt;/p&gt;
&lt;p&gt;Now we understand the regular expression syntax used, we need to
understand the rest of the line. Compiling the regular expression
creates a special regular expression object, which we've bound to &lt;code&gt;p2&lt;/code&gt;,
and which can be used later. We do this by writing:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
for item in p2.finditer(line):&lt;br /&gt;
istr = item.group()&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;This calls the &lt;code&gt;finditer&lt;/code&gt; method of the &lt;code&gt;p2&lt;/code&gt; regular expression object
on the text string &lt;code&gt;line&lt;/code&gt;, which returns an iterator of all the
instances where the pattern represented by &lt;code&gt;p2&lt;/code&gt; was matched. We need to
do this because there could be more than one match in any given &lt;code&gt;line&lt;/code&gt;.
The second line returns the actual matched text string from &lt;code&gt;item&lt;/code&gt;,
using the &lt;code&gt;group&lt;/code&gt; method, and puts it into &lt;code&gt;istr&lt;/code&gt;. We now have the full
thing:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
# Loop over all matches against p2 in line&lt;br /&gt;
for item in p2.finditer(line):&lt;/p&gt;
&lt;p&gt;# Extract the matched text&lt;br /&gt;
istr = item.group()&lt;/p&gt;
&lt;p&gt;# Create the unique reference (and increment the counter for next
time)&lt;br /&gt;
refidstr = 'fn'+str(refnum)&lt;br /&gt;
refnum += 1&lt;/p&gt;
&lt;p&gt;# Get the in-line reference text&lt;br /&gt;
fields = istr.split()&lt;br /&gt;
reftxt = " ".join(fields[2:]).strip('"')&lt;/p&gt;
&lt;p&gt;# Construct the WordPress-format inline reference and&lt;br /&gt;
# replace the old Doxygen-format one&lt;br /&gt;
ostr = '&lt;a href="\#'+refidstr+'"&gt;'+reftxt+'&lt;/a&gt;'&lt;br /&gt;
line = line.replace(istr,ostr)&lt;/p&gt;
&lt;p&gt;# Get the full reference text to use as the footnote&lt;br /&gt;
doxref = fields[1]&lt;br /&gt;
fr.seek(0)&lt;br /&gt;
for refline in fr:&lt;br /&gt;
if doxref in refline:&lt;br /&gt;
reffull = ' '.join(refline.strip().split()[3:])&lt;br /&gt;
break&lt;br /&gt;
footnotes.append('&lt;a name="'+refidstr+'"&gt;'+reffull+'&lt;/a&gt;')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;The only additonal thing here that you haven't already seen is the
&lt;code&gt;fr.seek(0)&lt;/code&gt; line, which rewinds the references file to the beginning
each time we do a search through it. It's common snafu in Python that
once you've done a &lt;code&gt;for line in file:&lt;/code&gt;-type of construct, you can't just
do another one. The file pointer is left at the end, so the second time
round nothing will happen (and it's not an error).&lt;/p&gt;
&lt;h3&gt;Maths&lt;/h3&gt;
&lt;p&gt;The final set of replacement operations we want to conduct is to replace
any Doxygen-style maths delimiters with the appropriate WordPress ones.
Doxygen allows several different kinds of delimiter. Firstly, in-line
equations can be included by surrounding them with &lt;code&gt;\f$&lt;/code&gt; tags; e.g.:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;...the equation \f$ E = mc^2 \f$ is well-known...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Alternatively, we can create a numbered equation on its own line by
using the opening delimiter &lt;code&gt;\f{equation}&lt;/code&gt; and the closing delimiter
&lt;code&gt;\f}&lt;/code&gt;. For example:&lt;/p&gt;
&lt;p&gt;[code]&lt;br /&gt;
\f{equation}&lt;br /&gt;
F = ma&lt;br /&gt;
\f}&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;Then finally, a non-numbered equation can be created on its own line by
using:&lt;/p&gt;
&lt;p&gt;[code]&lt;br /&gt;
\f[&lt;br /&gt;
a^2 + b^2 = c^2&lt;br /&gt;
\f]&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;In WordPress, there is only one way to embed mathematics, which is to
use the opening delimiter &lt;code&gt;$latex&lt;/code&gt; followed by the closing delimiter
&lt;code&gt;$&lt;/code&gt;. This is used whether we want the maths in-line or on its own line;
there's no support for equation numbering.&lt;/p&gt;
&lt;p&gt;Replacing the second two types is trivial, because the opening and
closing delimiters are different, as they are for WordPress. Hence:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
# Replace the maths delimiters&lt;br /&gt;
line = line.replace('\\f{equation}','&lt;span class="math"&gt;\(')  
line = line.replace('\\\\f[','\)&lt;/span&gt;')&lt;br /&gt;
line = line.replace('\\f}','&lt;span class="math"&gt;\(')  
line = line.replace('\\\\f]','\)&lt;/span&gt;')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;does the trick nicely. Note we add an extra &lt;code&gt;\&lt;/code&gt; to protect the &lt;code&gt;\&lt;/code&gt; that
appears in the string we want to match. Without this, the &lt;code&gt;\f&lt;/code&gt; would be
interpreted as the form-feed escape sequence.&lt;/p&gt;
&lt;p&gt;For the in-line equations it's slightly more complex, because the start
and end delimiter in Doxygen are the same, but we need to replace them
with different start and end delimiters for WordPress to understand. We
go back to regular expressions:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
# Replace the inline maths delimiters&lt;br /&gt;
for item in p1.finditer(line):&lt;br /&gt;
istr = item.group()&lt;br /&gt;
ostr = '&lt;span class="math"&gt;\('+istr.strip('@f\)&lt;/span&gt;')+'$'&lt;br /&gt;
line = line.replace(istr,ostr)&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;We saw &lt;code&gt;p1&lt;/code&gt; defined earlier as:&lt;/p&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
p1 = re.compile('@f\&lt;span class="math"&gt;\([^@]*@f\\\)&lt;/span&gt;')&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;Here we are trying to match something that begins and ends with a
literal &lt;code&gt;@f$&lt;/code&gt;, which we have to write as &lt;code&gt;@f$&lt;/code&gt; because &lt;code&gt;$&lt;/code&gt; is also a
special character in the regular expression language, but we want it to
be interpreted literally. In between we will allow any expression of any
length as long as it doesn't contain a &lt;code&gt;@&lt;/code&gt; symbol. This is represented
by &lt;code&gt;[^@]*&lt;/code&gt;. The rest should be self-explanatory.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;So that's a lengthy explanation of a fairly short and simple script (it
certainly took a lot longer to write...). It's also a fairly esoteric
use case I should think, so will probably be of use to all of 3 other
people if I'm lucky! The final, full script is reproduced below.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;[code lang="python"]&lt;br /&gt;
import sys&lt;br /&gt;
import os&lt;br /&gt;
import re&lt;/p&gt;
&lt;h2&gt;#&lt;/h2&gt;
&lt;p&gt;def checkfile(filename):&lt;/p&gt;
&lt;p&gt;errmsg = []&lt;/p&gt;
&lt;p&gt;filebase, fileext = os.path.splitext(filename)&lt;/p&gt;
&lt;p&gt;if fileext != '.md':&lt;br /&gt;
errmsg.append(filename+' is not Markdown')&lt;/p&gt;
&lt;p&gt;if not os.path.isfile(filename):&lt;br /&gt;
errmsg.append(filename+' does not exist or is not&lt;br /&gt;
a file')&lt;/p&gt;
&lt;p&gt;return errmsg&lt;/p&gt;
&lt;h2&gt;#&lt;/h2&gt;
&lt;p&gt;def processfile(filename,reffile='references.md'):&lt;/p&gt;
&lt;p&gt;fi = open(filename,'r')&lt;br /&gt;
fo = open(filename+'.txt','w')&lt;br /&gt;
fr = open(reffile,'r')&lt;/p&gt;
&lt;p&gt;p1 = re.compile('@f\&lt;span class="math"&gt;\([^@]*@f\\\)&lt;/span&gt;')&lt;br /&gt;
p2 = re.compile('@ref [^"]&lt;em&gt; "[^"]&lt;/em&gt;"')&lt;/p&gt;
&lt;p&gt;refnum = 1&lt;br /&gt;
footnotes = []&lt;/p&gt;
&lt;p&gt;for line in fi:&lt;/p&gt;
&lt;p&gt;# Some of the later changes insert "&amp;lt;" and "&amp;gt;" so do these&lt;br /&gt;
# as early as possible&lt;br /&gt;
line = line.replace('&amp;lt;','&amp;lt;')&lt;br /&gt;
line = line.replace('&amp;gt;','&amp;gt;')&lt;/p&gt;
&lt;p&gt;# Remove the table of contents special command&lt;br /&gt;
line = line.replace('\\tableofcontents','')&lt;/p&gt;
&lt;p&gt;# Replace the Doxygen special commands for sections with&lt;br /&gt;
# Markdown&lt;br /&gt;
if '\section' in line:&lt;br /&gt;
fields = line.split()&lt;br /&gt;
line = '# ' + ' '.join(fields[2:])&lt;br /&gt;
if '\subsection' in line:&lt;br /&gt;
fields = line.split()&lt;br /&gt;
line = '## ' + ' '.join(fields[2:])&lt;br /&gt;
if '\subsubsection' in line:&lt;br /&gt;
fields = line.split()&lt;br /&gt;
line = '### ' + ' '.join(fields[2:])&lt;/p&gt;
&lt;p&gt;# References&lt;br /&gt;
# Doxygen format is '@ref doxref "reference text"'&lt;br /&gt;
# Replace with an HTML link to a footnote '&lt;a href="fn1"&gt;reference
text&lt;/a&gt;'&lt;br /&gt;
for item in p2.finditer(line):&lt;br /&gt;
istr = item.group()&lt;br /&gt;
refidstr = 'fn'+str(refnum)&lt;br /&gt;
fields = istr.split()&lt;br /&gt;
reftxt = " ".join(fields[2:]).strip('"')&lt;br /&gt;
doxref = fields[1]&lt;br /&gt;
fr.seek(0)&lt;br /&gt;
for refline in fr:&lt;br /&gt;
if doxref in refline:&lt;br /&gt;
reffull = ' '.join(refline.strip().split()[3:])&lt;br /&gt;
break&lt;br /&gt;
ostr = '&lt;a href="\#'+refidstr+'"&gt;'+reftxt+'&lt;/a&gt;'&lt;br /&gt;
line = line.replace(istr,ostr)&lt;br /&gt;
footnotes.append('&lt;a name="'+refidstr+'"&gt;'+reffull+'&lt;/a&gt;')&lt;br /&gt;
refnum += 1&lt;/p&gt;
&lt;p&gt;# Replace the maths delimiters&lt;br /&gt;
line = line.replace('\\f{equation}','&lt;span class="math"&gt;\(')  
line = line.replace('\\\\f[','\)&lt;/span&gt;')&lt;br /&gt;
line = line.replace('\\f}','&lt;span class="math"&gt;\(')  
line = line.replace('\\\\f]','\)&lt;/span&gt;')&lt;/p&gt;
&lt;p&gt;# Replace the inline maths delimiters&lt;br /&gt;
for item in p1.finditer(line):&lt;br /&gt;
istr = item.group()&lt;br /&gt;
ostr = '&lt;span class="math"&gt;\('+istr.strip('@f\)&lt;/span&gt;')+'$'&lt;br /&gt;
line = line.replace(istr,ostr)&lt;/p&gt;
&lt;p&gt;fo.write(line+'\n')&lt;/p&gt;
&lt;p&gt;# Write out the footnotes generated by processing the references&lt;br /&gt;
fo.write('&lt;hr&gt;\n')&lt;br /&gt;
fo.write('&lt;ol&gt;\n')&lt;br /&gt;
for fn in footnotes:&lt;br /&gt;
fo.write('&lt;li&gt;'+fn+'\n')&lt;br /&gt;
fo.write('&lt;/ol&gt;\n')&lt;/p&gt;
&lt;p&gt;fi.close()&lt;br /&gt;
fo.close()&lt;br /&gt;
fr.close()&lt;/p&gt;
&lt;p&gt;return&lt;/p&gt;
&lt;h2&gt;#&lt;/h2&gt;
&lt;p&gt;def processdox(filename,reffile):&lt;/p&gt;
&lt;p&gt;errmsg = checkfile(filename)&lt;/p&gt;
&lt;p&gt;if len(errmsg) == 0:&lt;br /&gt;
processfile(filename,reffile=reffile)&lt;/p&gt;
&lt;p&gt;return errmsg&lt;/p&gt;
&lt;h2&gt;#&lt;/h2&gt;
&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == "&lt;strong&gt;main&lt;/strong&gt;":&lt;/p&gt;
&lt;p&gt;args = sys.argv[1:]&lt;/p&gt;
&lt;p&gt;reffile = '/default/path/to/references.md'&lt;/p&gt;
&lt;p&gt;for arg in args:&lt;br /&gt;
errmsg = processdox(arg,reffile)&lt;br /&gt;
for msg in errmsg:&lt;br /&gt;
print msg&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="doxygen"></category><category term="latex"></category><category term="markdown"></category><category term="python"></category><category term="regular expressions"></category><category term="text processing"></category><category term="wordpress"></category></entry></feed>